<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.16.4 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/extra.css">
<link rel="stylesheet" href="/css/minimal-mistakes.css">
<link rel="stylesheet" href="/css/adjust.css">
<link rel="stylesheet" href="/css/luminous-basic.min.css">
<link rel="icon" href="/assets/favicon.ico">
<link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/earlyaccess/notosansjp.css" rel="stylesheet">
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> -->

<!--[if IE ]>
<style>
  /* old IE unsupported flexbox fixes */
  .greedy-nav .site-title {
    padding-right: 3em;
  }
  .greedy-nav button {
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
  }
</style>
<![endif]-->

   <title>juliaで前処理大全3</title>  
  <!-- end custom head snippets -->
</head>
<body class="layout--single">
  <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="/">Hanafsky.com</a>
        <ul class="visible-links">
          <li class="masthead__menu-item"><a href="/tips/" >Julia-tips</a></li>
          <li class="masthead__menu-item"><a href="/blog/" >Blog</a></li>
          <li class="masthead__menu-item"><a href="/project/" >Projects</a></li>
          <li class="masthead__menu-item"><a href="/about/">About</a></li>
        </ul>
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

  <div class="initial-content">
    <div id="main" role="main">
      <div class="sidebar sticky">
        <div itemscope itemtype="https://schema.org/Person">
          <div class="author__avatar">
            <img src="/assets/design/author3.png" alt="Dio" itemprop="image">
          </div>
          <div class="author__content">
            <h3 class="author__name" itemprop="name">Kei Hanafusa</h3>
            <p class="author__bio" itemprop="description">Chemical Engineer, <br> living in Osaka, 🗾</p>
          </div>
          <div class="author__urls-wrapper">
            <button class="btn btn--inverse">Follow</button>
            <ul class="author__urls social-icons">
              <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
                <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Osaka, Japan</span></li>
              <li><a href="https://twitter.com/hanafusakei" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
              <li><a href="https://github.com/hanafsky" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
            </ul>
          </div>

          
          
              

          <div class="author__urls-wrapper">
            <button class="btn btn--inverse">Tag</button>
            <ul class="author__urls social-icons">
              <li>タグ</li>
              <li></li>
              <li><a href="/tag/setting/">設定</a></li>
              <li><a href="/tag/thirdparty/">サードパーティライブラリ</a></li>
              <li><a href="/tag/recipe">レシピ</a></li>
            </ul>
          </div>
          
        </div>
      </div>


<!-- Content appended here -->
<div class="franklin-content"><h1 id="juliaで前処理大全_4結合"><a href="#juliaで前処理大全_4結合" class="header-anchor">juliaで前処理大全 4.結合</a></h1>
<p>juliaで前処理大全その3です。今回は結合を扱います。</p>
<div class="franklin-toc"><ol><li><a href="#準備">準備</a></li><li><a href="#結合">結合</a><ol><li><a href="#マスターテーブルの結合">マスターテーブルの結合</a></li><li><a href="#条件に応じた結合テーブルの切り替え">条件に応じた結合テーブルの切り替え</a></li><li><a href="#過去データの結合">過去データの結合</a></li><li><a href="#全結合">全結合</a></li></ol></li></ol></div>
<h2 id="準備"><a href="#準備" class="header-anchor">準備</a></h2>
<p>まずは、ホテルの予約データ<code>reserve.csv</code>を読み込みます。 <code>hotel.csv</code>と<code>customer.csv</code>も結合処理に利用するので、一緒に読み込みます。 予約日時の列（:reserve_datetime）がStringで読み込まれているので、DateTime型に変更します。</p>
<pre><code class="language-julia">using DataFrames,CSV,Chain,Downloads,NaturalSort
reserve_url &#61; &quot;https://raw.githubusercontent.com/hanafsky/awesomebook/master/data/reserve.csv&quot;
hotel_url &#61; &quot;https://raw.githubusercontent.com/hanafsky/awesomebook/master/data/hotel.csv&quot;
customer_url &#61; &quot;https://raw.githubusercontent.com/hanafsky/awesomebook/master/data/customer.csv&quot;

reserve_df &#61; @chain reserve_url Downloads.download CSV.File DataFrame
hotel_df &#61; @chain hotel_url Downloads.download CSV.File DataFrame
customer_df &#61; @chain customer_url Downloads.download CSV.File DataFrame
using Dates
reserve_df.reserve_datetime &#61; DateTime.&#40;reserve_df.reserve_datetime, dateformat&quot;yyyy-mm-dd HH:MM:SS&quot;&#41;
first&#40;hotel_df&#41; |&gt; println</code></pre>
<p><div class="code-output"><pre><code class="plaintext code-output">DataFrameRow
 Row │ hotel_id  base_price  big_area_name  small_area_name  hotel_latitude  hotel_longitude  is_business
     │ String7…  Int64       String1…       String3…         Float64         Float64          Bool
─────┼────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │ h_1            26100  D              D-2                     43.0646          141.511         true
</code></pre></div> <div class="note"><div class="title">😲 Note</div>
<div class="content"><p>customer_idで自然なソートを行うために、NaturalSort.jlをインポートしています。</p>

<a href="https://github.com/JuliaStrings/NaturalSort.jl"><img src="https://github-link-card.s3.ap-northeast-1.amazonaws.com/JuliaStrings/NaturalSort.jl.png" width="460px"></a>

<pre><code class="language-julia">sort&#40;df,:customer_id,lt&#61;natural&#41;</code></pre>
<p>のように使っています。 普通にソートするとこのようになってしまいますが、</p>
<pre><code class="language-julia">c_1
c_10
c_100</code></pre>
<p>NaturalSort.jlを使うと、</p>
<pre><code class="language-julia">c_1
c_2
c_3</code></pre>
<p>のように、適切に並べ替えてくれます。</p></div></div></p>
<h2 id="結合"><a href="#結合" class="header-anchor">結合</a></h2>
<h3 id="マスターテーブルの結合"><a href="#マスターテーブルの結合" class="header-anchor">マスターテーブルの結合</a></h3>
<p><code>reserve_df</code>と<code>hotel_df</code>を<code>:hotel_id</code>が等しいデータ同士で結合します。 ただし、宿泊人数が1かつビジネスホテルであるという条件付きです。</p>
<p>ポイントとなるのは、結合処理を行う前にフィルター処理を行って、 結合するデータのサイズをなるべく小さくすることらしいです。</p>
<p>結合処理には、&quot;双方に存在するデータ&quot;同士での統合なので、内部結合の関数<code>innerjoin</code>を利用します。 今回は一度フィルターをかけるだけなので、@chainマクロによるパイプライン処理は使っていません。</p>
<pre><code class="language-julia">innerjoin&#40;filter&#40;:people_num&#61;&gt;&#61;&#61;&#40;1&#41;,reserve_df&#41;,
          filter&#40;:is_business&#61;&gt;&#61;&#61;&#40;true&#41;,hotel_df&#41;,
          on&#61;:hotel_id&#41; |&gt; first |&gt; println</code></pre>
<div class="code-output"><pre><code class="plaintext code-output">DataFrameRow
 Row │ reserve_id  hotel_id  customer_id  reserve_datetime     checkin_date  checkin_time  checkout_date  people_num  total_price  base_price  big_area_name  small_area_name  hotel_latitude  hotel_longitude  is_business
     │ String7…    String7…  String7…     Dates.DateTime       Dates.Date    Dates.Time    Dates.Date     Int64       Int64        Int64       String1…       String3…         Float64         Float64          Bool
─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │ r7          h_256     c_1          2017-12-29T10:38:36  2018-01-25    10:30:00      2018-01-28              1       103500       34500  C              C-1                     38.2373          140.696         true
</code></pre></div>
<h3 id="条件に応じた結合テーブルの切り替え"><a href="#条件に応じた結合テーブルの切り替え" class="header-anchor">条件に応じた結合テーブルの切り替え</a></h3>
<p>あるホテルと同じ地域にあるホテルを推薦リストを作る例題です。 複数のマスターテーブルをつくる必要があるため、なかなか複雑です。 前処理大全とは順番を変えて、先にレコメンド候補のテーブルを作っておくことにします。 こうすると、あとは1回のパイプラインで処理をまとめることが可能になります。</p>
<p>複数列を1つの列にまとめる作業をstack関数で実施できますし、かなりAwesomeな書き方だと思います。</p>
<p>ただし、処理が複雑なので、すっきり書いてもわかりにくいです。</p>
<pre><code class="language-julia">using Chain
recommend_hotel_mst &#61; @chain hotel_df begin
  select&#40;:hotel_id,:big_area_name,:small_area_name&#41;
  stack&#40;&#91;:big_area_name,:small_area_name&#93;,value_name&#61;:join_area_id&#41;
  select&#40;:hotel_id&#61;&gt;:rec_hotel_id,:join_area_id&#41;
end

base_hotel_mst &#61; @chain hotel_df begin
  groupby&#40;&#91;:big_area_name,:small_area_name&#93;&#41; # big_area,small_area毎にグループ分け
  combine&#40;:hotel_id&#61;&gt;&#40;r-&gt;length&#40;r&#41;-1&#41;&#61;&gt;:hotel_cnt&#41; # hotel_idの数をカウント&#40;自分をのぞく&#41;
  transform&#40;&#91;:hotel_cnt,:big_area_name,:small_area_name&#93;&#61;&gt;
            &#40;&#40;a,b,c&#41;-&gt;ifelse.&#40;a.&gt;20,c,b&#41;&#41;&#61;&gt;:join_area_id&#41; # カウント数が20以下ならbig_areaをjoin_area_idに設定
  select&#40;:small_area_name,:join_area_id&#41; 
  innerjoin&#40;hotel_df,_,on&#61;:small_area_name&#41; # hotel_dfと:small_area_nameで内部結合する。
  select&#40;:hotel_id,:join_area_id&#41; 
  innerjoin&#40;_,recommend_hotel_mst, on&#61;:join_area_id&#41; # レコメンド候補を結合する。
  filter&#40;&#91;:hotel_id,:rec_hotel_id&#93;&#61;&gt;&#40;&#40;a,b&#41;-&gt;a .&#33;&#61; b&#41; ,_&#41; # 自分ホテルをのぞく
  select&#40;:hotel_id,:rec_hotel_id&#41;
end

first&#40;base_hotel_mst,10&#41; |&gt; println</code></pre>
<div class="code-output"><pre><code class="plaintext code-output">10×2 DataFrame
 Row │ hotel_id  rec_hotel_id
     │ String7…  String7…
─────┼────────────────────────
   1 │ h_14      h_1
   2 │ h_22      h_1
   3 │ h_27      h_1
   4 │ h_40      h_1
   5 │ h_45      h_1
   6 │ h_77      h_1
   7 │ h_79      h_1
   8 │ h_85      h_1
   9 │ h_91      h_1
  10 │ h_103     h_1
</code></pre></div>
<h3 id="過去データの結合"><a href="#過去データの結合" class="header-anchor">過去データの結合</a></h3>
<h4 id="q_n件前のデータ取得"><a href="#q_n件前のデータ取得" class="header-anchor">Q n件前のデータ取得</a></h4>
<p>2回前の予約時の支払い額を、新たな列（before_price）として追加するという例題です。</p>
<p>以下のような流れでプログラムを書いていきます。</p>
 <div style="text-align:center" class="mermaid"> 
graph TD
  id1(custormer_id,reserve_datetimeで並べ替え)
  id2(customer_idについてgroupbyを適用)
  id3(lag関数を使って2件前の支払い額を調べる)
  id1-->id2
  id2-->id3
 </div>
<p>前処理大全と順番が違うのは、sortをGroupedDataFrameに対して直接適用できないからです。</p>
<p>まず、lag関数を使うために、ShiftedArrays.jlを読み込みます。 transform関数は新たな列を作れる機能がselect関数と似ていますが、 select関数と異なり、選択していない列も保存されます。 GroupedDataFrameにtransform関数を作用させると、ただのDataFrame型に戻るようです。</p>
<pre><code class="language-julia">using Chain, ShiftedArrays

@chain reserve_df begin
  sort&#40;:reserve_datetime&#41;
  sort&#40;:customer_id,lt&#61;natural&#41;
  groupby&#40;:customer_id&#41;
  transform&#40;:total_price&#61;&gt;&#40;r-&gt;lag&#40;r,2&#41;&#41;&#61;&gt;:before_price&#41;
  select&#40;:customer_id,:reserve_datetime,:total_price,:before_price&#41; # 表示する列を選択
  first&#40;_,15&#41; # 15件目のレコードまで選択
  println
end</code></pre>
<div class="code-output"><pre><code class="plaintext code-output">15×4 DataFrame
 Row │ customer_id  reserve_datetime     total_price  before_price
     │ String7…     Dates.DateTime       Int64        Int64?
─────┼─────────────────────────────────────────────────────────────
   1 │ c_1          2016-03-06T13:09:42        97200       missing
   2 │ c_1          2016-07-16T23:39:55        20600       missing
   3 │ c_1          2016-09-24T10:03:17        33600         97200
   4 │ c_1          2017-03-08T03:20:10       194400         20600
   5 │ c_1          2017-09-05T19:50:37        68100         33600
   6 │ c_1          2017-11-27T18:47:05        36000        194400
   7 │ c_1          2017-12-29T10:38:36       103500         68100
   8 │ c_1          2018-05-26T08:42:51         6000         36000
   9 │ c_2          2016-03-05T13:31:06        68400       missing
  10 │ c_2          2016-06-25T09:12:22       320400       missing
  11 │ c_2          2016-11-19T12:49:10        29700         68400
  12 │ c_2          2017-05-24T10:06:21        81600        320400
  13 │ c_2          2017-10-19T03:03:30       137000         29700
  14 │ c_2          2018-02-18T05:12:58        75600         81600
  15 │ c_2          2018-04-19T11:25:00        68800        137000
</code></pre></div>
<p>初回と2回目の予約レコードについては、前々回の支払金額がmissingとして追加されていることがわかります。</p>
<h4 id="q_過去n件の合計値"><a href="#q_過去n件の合計値" class="header-anchor">Q 過去n件の合計値</a></h4>
<p>今度は同一顧客の過去3件の予約金額の合計値を出力する例題です。 Rのrun_sum関数に相当するものとしては、RollingFunctions.jlが使えそうです。 <code>rolling&#40;f::Function, v::Vector, window::Int64&#41;</code>の形式で呼び出してみます。</p>
<pre><code class="language-julia">using RollingFunctions
rolling&#40;sum, &#91;1,2,3,4,5&#93;,3&#41;</code></pre><pre><code class="plaintext code-output">3-element Vector{Float64}:
  6.0
  9.0
 12.0</code></pre>
<p>もとの配列と同じ長さで、3つ毎に足した和が得られているはずです。 ただし、最初と2つ目のデータは、3つ分のデータはありませんから、missingに置き換えたいです。 また、そもそもデータ数が窓幅より少ない場合もmissingを返したいですね。</p>
<p>このような関数をroll_sumとして実装してみましょう。</p>
<pre><code class="language-julia">function roll_sum&#40;v,window&#61;3&#41;
  length&#40;v&#41; &lt; window ? Vector&#123;Missing&#125;&#40;undef,length&#40;v&#41;&#41; : 
                       vcat&#40;Vector&#123;Missing&#125;&#40;undef,window-1&#41;,rolling&#40;sum,v,window&#41;&#41;
end
roll_sum&#40;&#91;1,2,3,4,5&#93;,3&#41;</code></pre><pre><code class="plaintext code-output">5-element Vector{Union{Missing, Float64}}:
   missing
   missing
  6.0
  9.0
 12.0</code></pre>
<p>前の例のlag関数をroll<em>sumで置き換えて、新たに:price</em>sumの列を作ります。 DataFrames.jlでは、適当に作った関数を用いて、すっきりした処理を記載することができました。 <span class="marker"> 対応する処理が既存のライブラリになければ、作ってしまえばよい</span>のです。 これは処理が高速なjuliaならでは強みだと思います。</p>
<pre><code class="language-julia">using Chain, ShiftedArrays

@chain reserve_df begin
  sort&#40;:reserve_datetime&#41;
  sort&#40;:customer_id,lt&#61;natural&#41;
  groupby&#40;:customer_id&#41;
  transform&#40;:total_price&#61;&gt;roll_sum&#61;&gt;:price_sum&#41;
  select&#40;:customer_id,:reserve_datetime,:total_price,:price_sum&#41; # 表示する列を選択
  first&#40;_,15&#41; # 15件目のレコードまで選択
  println
end</code></pre>
<div class="code-output"><pre><code class="plaintext code-output">15×4 DataFrame
 Row │ customer_id  reserve_datetime     total_price  price_sum
     │ String7…     Dates.DateTime       Int64        Float64?
─────┼──────────────────────────────────────────────────────────
   1 │ c_1          2016-03-06T13:09:42        97200  missing
   2 │ c_1          2016-07-16T23:39:55        20600  missing
   3 │ c_1          2016-09-24T10:03:17        33600   151400.0
   4 │ c_1          2017-03-08T03:20:10       194400   248600.0
   5 │ c_1          2017-09-05T19:50:37        68100   296100.0
   6 │ c_1          2017-11-27T18:47:05        36000   298500.0
   7 │ c_1          2017-12-29T10:38:36       103500   207600.0
   8 │ c_1          2018-05-26T08:42:51         6000   145500.0
   9 │ c_2          2016-03-05T13:31:06        68400  missing
  10 │ c_2          2016-06-25T09:12:22       320400  missing
  11 │ c_2          2016-11-19T12:49:10        29700   418500.0
  12 │ c_2          2017-05-24T10:06:21        81600   431700.0
  13 │ c_2          2017-10-19T03:03:30       137000   248300.0
  14 │ c_2          2018-02-18T05:12:58        75600   294200.0
  15 │ c_2          2018-04-19T11:25:00        68800   281400.0
</code></pre></div>
<h4 id="q_過去n件の平均値"><a href="#q_過去n件の平均値" class="header-anchor">Q 過去n件の平均値</a></h4>
<p>この例題では、</p>
<p>平均値を出す関数としては、runmean関数が使えそうです。</p>
<pre><code class="language-julia">using RollingFunctions
runmean&#40;&#91;1,2,3,4,5&#93;,3&#41;</code></pre><pre><code class="plaintext code-output">5-element Vector{Float64}:
 1.0
 1.5
 2.0
 3.0
 4.0</code></pre>
<p>ただし、自身の行を含めない平均予約金額であり、 過去に予約がない場合はmissingを割り当てたいので、 以下のような関数を作ることにします。</p>
<pre><code class="language-julia">function price_avg&#40;v,window&#61;3&#41;
  length&#40;v&#41; &lt; window ? vcat&#40;missing,runmean&#40;v,length&#40;v&#41;&#41;&#91;begin:end-1&#93;&#41; :
                       vcat&#40;missing,runmean&#40;v,window&#41;&#91;begin:end-1&#93;&#41;
end
price_avg&#40;&#91;1,2,3,4,5&#93;,3&#41;</code></pre><pre><code class="plaintext code-output">5-element Vector{Union{Missing, Float64}}:
  missing
 1.0
 1.5
 2.0
 3.0</code></pre>
<p>うまく動作することを確認できました。</p>
<pre><code class="language-julia">using Chain, ShiftedArrays

@chain reserve_df begin
  sort&#40;:reserve_datetime&#41;
  sort&#40;:customer_id,lt&#61;natural&#41;
  groupby&#40;:customer_id&#41;
  transform&#40;:total_price&#61;&gt;price_avg&#61;&gt;:price_avg&#41;
  select&#40;:customer_id,:reserve_datetime,:total_price,:price_avg&#41; # 表示する列を選択
  first&#40;_,15&#41; # 15件目のレコードまで選択
  println
end</code></pre>
<div class="code-output"><pre><code class="plaintext code-output">15×4 DataFrame
 Row │ customer_id  reserve_datetime     total_price  price_avg
     │ String7…     Dates.DateTime       Int64        Float64?
─────┼──────────────────────────────────────────────────────────
   1 │ c_1          2016-03-06T13:09:42        97200  missing
   2 │ c_1          2016-07-16T23:39:55        20600    97200.0
   3 │ c_1          2016-09-24T10:03:17        33600    58900.0
   4 │ c_1          2017-03-08T03:20:10       194400    50466.7
   5 │ c_1          2017-09-05T19:50:37        68100    82866.7
   6 │ c_1          2017-11-27T18:47:05        36000    98700.0
   7 │ c_1          2017-12-29T10:38:36       103500    99500.0
   8 │ c_1          2018-05-26T08:42:51         6000    69200.0
   9 │ c_2          2016-03-05T13:31:06        68400  missing
  10 │ c_2          2016-06-25T09:12:22       320400    68400.0
  11 │ c_2          2016-11-19T12:49:10        29700   194400.0
  12 │ c_2          2017-05-24T10:06:21        81600   139500.0
  13 │ c_2          2017-10-19T03:03:30       137000   143900.0
  14 │ c_2          2018-02-18T05:12:58        75600    82766.7
  15 │ c_2          2018-04-19T11:25:00        68800    98066.7
</code></pre></div>
<h4 id="q_過去n日の合計値"><a href="#q_過去n日の合計値" class="header-anchor">Q 過去n日の合計値</a></h4>
<p>予約テーブルのすべてのデータ行にたいして、自身の行を含めずに同じ顧客の過去90日間の合計予約金額を付与するという問題です。 &#40;予約がない場合は0&#41; 問題もだんだん難しくなってきており、RにもpythonもAwesomeな回答はありませんでした。</p>
<p>顧客ごとにグループ化するのは前の問題と共通していますので、過去の予約合計金額を計算する関数<code>total_price_history</code>を作ることにしました。 各予約日毎に自身の行を含めず、過去90日分の予約日をフィルターした日付を抽出します。 フィルターされた日付に含まれる場合について、予約金額の合計の和をとって ただし、フィルターされた列が空の場合は、0を返すことにします。 &#40;<code>enumerate</code>関数を多用しているので、ちょっとわかりにくいかもしれません。&#41;</p>
<pre><code class="language-julia">using Dates
function total_price_history&#40;reserve_dates,prices;day&#61;Day&#40;90&#41;&#41;
  tp &#61; similar&#40;prices&#41;
  for &#40;index,date&#41; in enumerate&#40;reserve_dates&#41;
    filtered_date &#61; filter&#40;&#40;&#40;d&#41;-&gt;date-day ≤ d &lt; date&#41;, reserve_dates&#41;
    tp&#91;index&#93; &#61; filtered_date&#61;&#61;DateTime&#91;&#93; ? 0 :
                sum&#40;prices&#91;i&#93; for &#40;i,d&#41; in enumerate&#40;reserve_dates&#41; if d in filtered_date&#41;
  end
  return tp
end

@chain reserve_df begin
  sort&#40;&#91;:customer_id,:reserve_datetime&#93;&#41;
  groupby&#40;:customer_id&#41;
  transform&#40;&#91;:reserve_datetime,:total_price&#93;&#61;&gt;total_price_history&#61;&gt;:total_price_90d&#41;
  select&#40;:customer_id,:reserve_datetime,:total_price,:total_price_90d&#41; # 表示する列を選択
  sort&#40;:customer_id,lt&#61;natural&#41;
  first&#40;_,15&#41; # 15件目のレコードまで選択
  println
end</code></pre>
<div class="code-output"><pre><code class="plaintext code-output">15×4 DataFrame
 Row │ customer_id  reserve_datetime     total_price  total_price_90d
     │ String7…     Dates.DateTime       Int64        Int64
─────┼────────────────────────────────────────────────────────────────
   1 │ c_1          2016-03-06T13:09:42        97200                0
   2 │ c_1          2016-07-16T23:39:55        20600                0
   3 │ c_1          2016-09-24T10:03:17        33600            20600
   4 │ c_1          2017-03-08T03:20:10       194400                0
   5 │ c_1          2017-09-05T19:50:37        68100                0
   6 │ c_1          2017-11-27T18:47:05        36000            68100
   7 │ c_1          2017-12-29T10:38:36       103500            36000
   8 │ c_1          2018-05-26T08:42:51         6000                0
   9 │ c_2          2016-03-05T13:31:06        68400                0
  10 │ c_2          2016-06-25T09:12:22       320400                0
  11 │ c_2          2016-11-19T12:49:10        29700                0
  12 │ c_2          2017-05-24T10:06:21        81600                0
  13 │ c_2          2017-10-19T03:03:30       137000                0
  14 │ c_2          2018-02-18T05:12:58        75600                0
  15 │ c_2          2018-04-19T11:25:00        68800            75600
</code></pre></div>
<p>このようにオーダーメイドの処理を自作することで、パイプライン処理をシンプルにまとめることができました。</p>
<h3 id="全結合"><a href="#全結合" class="header-anchor">全結合</a></h3>
<p>顧客ごとに2017年1月～2017年3月の月間利用料金を計算する問題です。 これも少々頭を悩ませました。 流れは以下のようになっています。</p>
 <div style="text-align:center" class="mermaid"> 
graph TD
  sub1(年月マスターのデータフレームを作成)
  sub2(顧客テーブルに対して年月マスターを全結合)
  id1(予約レコードから必要な列を抽出<br>customer_id,checkin_date,total_price)
  id2(チェックイン日を年月マスターの形式に合わせる)
  id3(年月マスターに対して結合<br>chainの都合上rightjoin)
  id4(顧客IDと年月でグループ分け)
  id5(予約金額を合計)
  id6(Missingを0に置き換え)
  subgraph 年月マスターの作成
  sub1-->sub2
  end
  id1-->id2
  id2-->id3
  id3-->id4
  id4-->id5
  id5-->id6
 </div>
<p>コード化したものがこちらです。</p>
<pre><code class="language-julia"># 年月マスタの生成
month_mst &#61; DataFrame&#40;:year_month&#61;&gt;&#91;Date&#40;&quot;2017-01-01&quot;&#41;&#43;Month&#40;m&#41; for m in 0:2&#93;&#41; 
customer_mst &#61; crossjoin&#40;customer_df,month_mst&#41;

summary_result &#61; @chain reserve_df begin
  select&#40;:customer_id,
         :checkin_date&#61;&gt;ByRow&#40;r-&gt;Date&#40;Year&#40;r&#41;,Month&#40;r&#41;&#41;&#41;&#61;&gt;:year_month,
         :total_price&#41;
  # customer_mstに対して結合したいのでleftjoinではなくrightjoinを使う。
  rightjoin&#40;customer_mst,on&#61;&#91;:customer_id,:year_month&#93;&#41; 
  groupby&#40;&#91;:customer_id,:year_month&#93;&#41;
  combine&#40;:total_price&#61;&gt;sum&#61;&gt;:price_sum&#41;
  sort&#40;:year_month&#41;
  sort&#40;:customer_id,lt&#61;natural&#41;
end
replace&#33;&#40;summary_result.price_sum,missing&#61;&gt;0&#41;

first&#40;summary_result,10&#41; |&gt; println</code></pre>
<p><div class="code-output"><pre><code class="plaintext code-output">10×3 DataFrame
 Row │ customer_id  year_month  price_sum
     │ String7…     Dates.Date  Int64?
─────┼────────────────────────────────────
   1 │ c_1          2017-01-01          0
   2 │ c_1          2017-02-01          0
   3 │ c_1          2017-03-01     194400
   4 │ c_2          2017-01-01          0
   5 │ c_2          2017-02-01          0
   6 │ c_2          2017-03-01          0
   7 │ c_3          2017-01-01          0
   8 │ c_3          2017-02-01     390600
   9 │ c_3          2017-03-01      18200
  10 │ c_4          2017-01-01          0
</code></pre></div> 本の通りの答えが得られていると思います。</p>
<p>この章の問題はかなり難しいため、問題を理解するのもコードを考えるのも、かなり骨が折れました。 しかし、自前で関数を用意する考えや、DataFrames.jlとChain.jlのおかげで、本のコードに勝るとも劣らない非常に<span class="marker"> Awesome</span>な処理ができたのではないかと思います。 
  <div class="prev-next-link">
  <a class="prev-link" href="/tips/preprocess/aggregation">
    <p class="prev-next-label">前の記事</p>
    <p>
       juliaで前処理大全 集約
    </p>
  </a>
</div>
</p>
 <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button> 
<div class="page-foot">
  <div class="copyright">
    &copy; Kei Hanafusa. Last modified: October 30, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->

      </div> <!-- closure of main -->
    </div>   <!-- closure of class initial--content -->

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->
        <!-- end custom footer snippets -->
        <div class="page__footer-follow">
          <ul class="social-icons">
            <li><strong>Follow:</strong></li>
            <li><a href="https://twitter.com/hanafusakei" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
            <li><a href="https://github.com/hanafsky" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
          </ul>
        </div>
        <div class="page__footer-copyright">&copy; Kei Hanafusa. Powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>
      </footer>
    </div>

    <script src="/libs/minimal-mistakes/main.min.js"></script>
    <script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" crossorigin="anonymous"></script>
    <script src="/libs/myBtn/myBtn.js"></script>
    <script src="/libs/luminous/Luminous.min.js"></script>
    <script src="/libs/clipboard.min.js"></script>

    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

        <!-- http://tutsplus.github.io/clipboard/ -->

<script>
	(function(){
	
		// Get the elements.
		// - the 'pre' element.
		// - the 'div' with the 'paste-content' id.
	
		var pre = document.getElementsByTagName('pre');
	
		// Add a copy button in the 'pre' element.
		// which only has the className of 'language-'.
	
		for (var i = 0; i < pre.length; i++) {
			var isLanguage = pre[i].children[0].className.indexOf('language-');
	
			if ( isLanguage === 0 ) {
				var button           = document.createElement('button');
						button.className = 'copy-button';
						button.textContent = 'Copy';
	
						pre[i].appendChild(button);
			}
		};
	
		// Run Clipboard
	
		var copyCode = new Clipboard('.copy-button', {
			target: function(trigger) {
				return trigger.previousElementSibling;
		}
		});
	
		// On success:
		// - Change the "Copy" text to "Copied".
		// - Swap it to "Copy" in 2s.
		// - Lead user to the "contenteditable" area with Velocity scroll.
	
		copyCode.on('success', function(event) {
			event.clearSelection();
			event.trigger.textContent = 'Copied';
			window.setTimeout(function() {
				event.trigger.textContent = 'Copy';
			}, 2000);
	
		});
	
		// On error (Safari):
		// - Change the  "Press Ctrl+C to copy"
		// - Swap it to "Copy" in 2s.
	
		copyCode.on('error', function(event) {
			event.trigger.textContent = 'Press "Ctrl + C" to copy';
			window.setTimeout(function() {
				event.trigger.textContent = 'Copy';
			}, 5000);
		});
	
	})();
	</script>
        <!-- {{ insert foot_copy.html }} -->
    
    
        <script src="/libs/mermaid/mermaid.min.js"></script>
<script>
  var config
  mermaid.initialize({
    theme: 'neutral',
    themeCSS: '\
               .mermaid-main-font {font-family:"Noto Sans JP"};\
               .section0, .section2{fill:#fadbda;opacity:0.3;};\
               .task0, .task1, .task2, .task3 {fill:#fadbda; stroke:#f6bdc0; stroke-width:1};\
               .grid {stroke:#666;stroke-width:0.5};\
               .node rect,\
               .node circle,\
               .node ellipse,\
               .node path,\
               .node polygon\
               {fill:rgba(253,237,228,0.5);\
                stroke: rgb(246,189,192)};\
               .arrowheadPath {fill:rgb(246,189,192);}\
               .edgePath .path {stroke:rgb(246,189,192);};\
               .cluster rect\
               {fill:rgba(255,249,177,0.3);\
                stroke:rgb(246,189,192)};\
               ',
    // themeCSS: '.node rect {fill:rgba(253,237,228,0.5); stroke: rgb(250,219,218)};',
    // logLevel: 3,
    // securityLevel: 'loose',
    // flowchart: { curve: 'basis' }
  });
</script>
    
    <script>
    new LuminousGallery(document.querySelectorAll('.zoom'));
</script>
    <script>
function myToc() {
    var x = document.getElementsByClassName("mytoc");
    if (x.style.display === "none") {
      x.style.display = "block";
    } else {
      x.style.display = "none";
    }
  } 
</script>
  </body>
</html>
